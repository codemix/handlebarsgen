// Generated by CoffeeScript 1.6.1

/*
The post-processor operates on the parsed AST and does things like
assigning the correct scope to variables.
*/


(function() {
  var PostProcessor;

  module.exports = PostProcessor = (function() {
    /*
    Initialize the post-processor.
    */

    function PostProcessor(config) {
      var attribute, value;
      if (config == null) {
        config = {};
      }
      for (attribute in config) {
        value = config[attribute];
        this[attribute] = value;
      }
    }

    /*
    Post-process an AST
    */


    PostProcessor.prototype.postprocess = function(ast) {
      var Nodes, keyName, keyStack, scopeName, stack, visit,
        _this = this;
      stack = [];
      keyStack = [];
      keyName = function() {
        return String.fromCharCode(105 + (keyStack.length - 1));
      };
      scopeName = function() {
        if (stack.length === 0) {
          return "scope";
        } else {
          return "context" + (String.fromCharCode(65 + (stack.length - 1)));
        }
      };
      Nodes = this.Nodes;
      visit = function(node) {
        var child, popKeyStack, popStack, _i, _len, _ref;
        if (node === String(node)) {
          return;
        }
        if (Nodes[node.type]) {
          node.toString = Nodes[node.type];
        } else {
          throw new Error("Invalid Node: " + node.type);
        }
        popStack = false;
        popKeyStack = false;
        if (node.subject != null) {
          visit(node.subject);
        }
        switch (node.type) {
          case "block":
            if (node.name === "each") {
              stack.push(scopeName());
              keyStack.push(keyName());
              node.scopeName = scopeName();
              node.keyName = keyName();
              popStack = true;
              popKeyStack = true;
            } else if (node.name === "with") {
              stack.push(scopeName());
              node.scopeName = scopeName();
              node.keyName = keyName();
              popStack = true;
            }
            break;
          case "partial":
            node.scopeName = scopeName();
            break;
          case "thisIdentifier":
            node.name = scopeName();
            break;
          case "keyIdentifier":
            node.name = keyName();
            break;
          case "identifier":
            node.scopeName = scopeName();
            break;
          case "accessor":
            node.scopeName = scopeName();
            visit(node.head);
            break;
          case "pathAccessor":
            node.scopeName = stack[stack.length - node.depth];
        }
        if (node.body != null) {
          if (Array.isArray(node.body)) {
            _ref = node.body;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              visit(child);
            }
          } else {
            visit(node.body);
          }
        }
        if (popStack) {
          stack.pop();
        }
        if (popKeyStack) {
          keyStack.pop();
        }
        return void 0;
      };
      visit(ast);
      return ast;
    };

    return PostProcessor;

  })();

}).call(this);
